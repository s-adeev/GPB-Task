Комментарии к выбору оформления таблицы "как в ТЗ" (от Заказчика):
Требования к структуре таблиц странноватые, но возможно "он художник, он так видит". Поэтому сделаем первый вариант в соотвествии с ТЗ и еще один предложим заказчику скорректированный, возможно что-то его заинтересует.

Попробуем реализовать на базе MySQL.
ENGINE=InnoDB   -- Судя по вашему логу в день прилетает до 500_000 строк. Удобнее использовать неблокирующуюся на чтение базу.
CHARSET=latin1; -- utf8mb4 не сильно нужна. В логе нет кирилицы. Тем более, что при использлвании utf8mb4 длина индекса сократится с 767 (для InnoDB) до 767/4 = 191, либо переходить на COMPRESSED строки, но это доп. нагрузка.
У postgresql.VARCHAR() аналог mysql.TEXT
KEY (id(255))   -- для поля TEXT необходимо указать размер ключа.
TIMESTAMP по умолчанию в mysql - NOT NULL.
Mysql.BOOL синоним mysql.TINYINT(1), но позволяет работать с true/false.
В MySQL HASH-индексы поддерживает только в таблицах HEAP. Используются для четкого сопоставления и не позволяют извлекать диапазон в отличии от B-tree.
STATUS - это зарезервированное слово, поэтому оформление поля только через гравис `status`.
KEY message.id не может быть PRIMARY, 
	т.к. записи "<= <> R=1RwtiW-0000T9-4K" (:blackhole:) 	отдадут одинаковый пустой id для разных записей.
	А по ТЗ мы должны их тоже сохранить.
	Тем более, что в PRIMARY должна попасть Вся запись и уместиться в размер длины индекса для однозначной идентификации. Поэтому фотмат TEXT для него - плохая реализация.
	Странно что с флагом <= приходят события только с одного адреса tpxmuwr@somehost.ru

Из-за того что информация об адресе в таблице `message` находится сразу после флага, можем ускорить поиск, фиксированно привязать LIKE к левому краю.


Желательно к исправлению:

В таблице `message` не хватает индексированного поля `address`, при том что поиск делаем именно по почтовому адресу.
Если осуществляем поиск по двум таблицам с одинаковыми данными - оптимальнее было бы иметь одинаковый набор столбцов, например для UNION.
Либо парсить лог в Одну таблицу, т.к. данные в `message` занимают примерно 25% полезных данных лога.
В варианте с Одной таблицей проще и удобнее делать выборку по адресу и дате с сортировкой, и не нагружать доп. работой сервер.
Помимо этого, такой вариант позволит сделать при необходимости пагенацию страницы.

Для поиска в поле `str`, можно было бы сделать на поле FULLTEXT индексацию и воспользоваться MATCH AGAINST, ... но были преценденты спонтанного разрастания FULLTEXT-индексов на таблицах InnoDB с забиванием дискового пространства. 
На MyISAM такой проблемы не наблюдалось.

DATETIME удобнее в использовании чем TIMESTAMP (хотя не поддерживает ON UPDATE).
Для поля `str` TEXT размером в 64kB многоват для данных. Максимальная строка в логе правее флага: 300 символов => VARCHAR(512)
Для поля `address` TEXT также избыточен. Длина почтового поля: 64@255 => VARCHAR(320)
Желательно добавить нумерацию строк в качестве PRIMARY KEY.




--------------------------------------------------------------------------
В файле .cfg находятся параметры для доступа к mysql базе.
Добавляем .htaccess для блокирования чтения .cfg и *.pm

Первоначально запускаем на сервере в консоле файл init для проверки наличия библиотек и таблиц.

Комментарии к init:
Непонятны разграничения и наличие прав на создание новой Базы/Таблицы с предоставленным login/passwd.
Педположим что с этими правами у нас есть права на CREATE/DROP таблицы и база уже Cоздана, иначе нужны админские права на CREATE DATABASE.

Постараемся обойтись минимальным комплектом модулей, чтобы не засорять память. 
Первые 2 модуля обычно уже есть в базовом комплекте.

Data::Dumper
CGI
DBD
DBI::mysql




--------------------------------------------------------------------------
Код тестировался на:
CentOS 7
perl v5.16.3
Apache v2.4.6 
MariaDB v5.5.52
Тестирование из под рутовых прав на базу.

Запуск парсера из консоли:
# log2table ./log/log.file
- Проверяется наличие файла

# log2table.v2 ./log/log.file
- Проверяется наличие файла
- Проверяется что мы уже забирали эти данные: первые N строк уже есть в таблице.
- Попытка ускорить INSERT
	На 7500 записей ушло 75 сек.
	Попытка с одним prepare() сделать цикл из execute(), ускорения не принесли.
	Генерить длинный VALUE (...),(...),(...) нет желания из-за неопределённости в данных на отлов ошибок и инжектов. 
	Через '?,?' чужие данные надежнее паковать.
	А вот если настроить права для пользователя telnet/apache на папку ./log, то вариант LOAD DATA LOCAL INFILE занимает всего 0.25 сек.




--------------------------------------------------------------------------
Web-страница: 
log2table.cgi
log2table.v2.cgi

Вывод на экран флага надо оставить для понимания лога.
Возможен неполный поиск с 'mail*'.

Загрузка файла и запуск парсера через web - добавлена в log2table.v2.cgi
Для работы загрузчика необходимо подправить права на создание/запись файлов в директорию ./log от имени apache.

Подключение к вебу красивых шаблонизаторов типа Bootstrap, Mojo, и т.п., на мой взгляд на данном этапе для одностраничной задачи избыточно. Вполне достаточно jquery.
Возможны несостыковки в кодировке, тестировалось на apache/cp1251.



